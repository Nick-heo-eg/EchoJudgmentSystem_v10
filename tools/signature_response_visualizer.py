#!/usr/bin/env python3
"""
üìä Signature Response Visualizer - YAML ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§ ÏãúÍ∞ÅÌôî ÎèÑÍµ¨
Í∞êÏ†ï √ó ÏãúÍ∑∏ÎãàÏ≤ò ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§Î•º ÏßÅÍ¥ÄÏ†ÅÏúºÎ°ú ÏãúÍ∞ÅÌôîÌïòÍ≥† Î∂ÑÏÑù

ÌïµÏã¨ Í∏∞Îä•:
- Í∞êÏ†ï(YÏ∂ï) √ó ÏãúÍ∑∏ÎãàÏ≤ò(XÏ∂ï) Îß§Ìä∏Î¶≠Ïä§ ÌûàÌä∏Îßµ
- ÏùëÎãµ ÏòàÏãú Î∞è ÌÜµÍ≥Ñ ÌëúÏãú
- ÏÉâÏÉÅ ÏΩîÎî©: ÏùëÎãµ Ïàò, Í≥µÎ™ÖÎèÑ, ÎßåÏ°±ÎèÑ
- Streamlit Í∏∞Î∞ò ÎåÄÏãúÎ≥¥Îìú ÏßÄÏõê
- Îß§Ìä∏Î¶≠Ïä§ ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù
- Í∞úÏÑ† ÌïÑÏöî ÏòÅÏó≠ ÏûêÎèô ÏãùÎ≥Ñ
"""

import yaml
import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
from pathlib import Path
import argparse
import warnings

warnings.filterwarnings("ignore")

# ÏùòÏ°¥ÏÑ± Í∞ÄÏö©ÏÑ± ÌôïÏù∏
try:
    import streamlit as st

    STREAMLIT_AVAILABLE = True
except ImportError:
    STREAMLIT_AVAILABLE = False
    print("‚ö†Ô∏è StreamlitÏù¥ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå. Í∏∞Î≥∏ ÏãúÍ∞ÅÌôîÎßå ÏßÄÏõêÎê©ÎãàÎã§.")

# matplotlib Í∞ÄÏö©ÏÑ± ÏòàÏô∏ Ï≤òÎ¶¨ Í∞úÏÑ†
try:
    import matplotlib.pyplot as plt
    import seaborn as sns

    MATPLOTLIB_AVAILABLE = True
except ImportError as e:
    MATPLOTLIB_AVAILABLE = False
    print(f"‚ö†Ô∏è matplotlib/seaborn ÎàÑÎùΩÎê®: {e}")
    print("üí° Ìï¥Í≤∞Î∞©Î≤ï: pip install matplotlib seaborn")

    # Mock Í∞ùÏ≤¥ ÏÉùÏÑ±
    class MockPlt:
        def __init__(self):
            pass

        def subplots(self, *args, **kwargs):
            raise ImportError(
                "matplotlibÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. pip install matplotlib seabornÏùÑ Ïã§ÌñâÌïòÏÑ∏Ïöî."
            )

        def __getattr__(self, name):
            raise ImportError(
                "matplotlibÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. pip install matplotlib seabornÏùÑ Ïã§ÌñâÌïòÏÑ∏Ïöî."
            )

    plt = MockPlt()
    sns = None

# ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï (matplotlibÍ∞Ä ÏûàÏùÑ ÎïåÎßå)
if MATPLOTLIB_AVAILABLE:
    try:
        plt.rcParams["font.family"] = [
            "DejaVu Sans",
            "Malgun Gothic",
            "AppleGothic",
            "sans-serif",
        ]
        plt.rcParams["axes.unicode_minus"] = False
    except Exception as e:
        print(f"‚ö†Ô∏è Ìè∞Ìä∏ ÏÑ§Ï†ï Ïã§Ìå®: {e}")
        pass


class SignatureResponseVisualizer:
    """ÏãúÍ∑∏ÎãàÏ≤ò ÏùëÎãµ Îß§Ìä∏Î¶≠Ïä§ ÏãúÍ∞ÅÌôîÍ∏∞"""

    def __init__(self, data_dir: str = "data", config_dir: str = "config"):
        self.data_dir = Path(data_dir)
        self.config_dir = Path(config_dir)

        # Îç∞Ïù¥ÌÑ∞ Î°úÎî©
        self.template_matrix = self._load_template_matrix()
        self.feedback_data = self._load_feedback_data()
        self.signature_profiles = self._load_signature_profiles()

        # Îß§Ìä∏Î¶≠Ïä§ Î∂ÑÏÑù
        self.matrix_analysis = self._analyze_matrix()

        print("üìä Signature Response Visualizer Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
        print(
            f"   üìã ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§: {self.matrix_analysis['signatures']}Í∞ú ÏãúÍ∑∏ÎãàÏ≤ò √ó {self.matrix_analysis['emotions']}Í∞ú Í∞êÏ†ï"
        )
        print(f"   üìà ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞: {len(self.feedback_data)}Í∞ú")
        print(f"   üìä ÏôÑÏÑ±ÎèÑ: {self.matrix_analysis['completion_rate']:.1%}")

    def generate_heatmap(
        self, metric: str = "response_count", save_path: str = None
    ) -> plt.Figure:
        """Îß§Ìä∏Î¶≠Ïä§ ÌûàÌä∏Îßµ ÏÉùÏÑ±"""
        if not MATPLOTLIB_AVAILABLE:
            print("‚ùå matplotlibÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïÑ ÌûàÌä∏ÎßµÏùÑ ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
            print("üí° Ìï¥Í≤∞Î∞©Î≤ï: pip install matplotlib seaborn")
            return None

        print(f"üé® ÌûàÌä∏Îßµ ÏÉùÏÑ±: {metric} Í∏∞Ï§Ä")

        # Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
        matrix_data = self._create_matrix_data(metric)

        # ÌûàÌä∏Îßµ ÏÉùÏÑ±
        fig, ax = plt.subplots(figsize=(12, 8))

        # Ïª¨Îü¨Îßµ ÏÑ†ÌÉù
        if metric == "satisfaction_score":
            cmap = "RdYlGn"
            vmin, vmax = 1.0, 5.0
        elif metric == "response_count":
            cmap = "YlOrRd"
            vmin, vmax = 0, matrix_data.values.max()
        else:
            cmap = "viridis"
            vmin, vmax = matrix_data.values.min(), matrix_data.values.max()

        # ÌûàÌä∏Îßµ Í∑∏Î¶¨Í∏∞
        sns.heatmap(
            matrix_data,
            annot=True,
            fmt=".1f" if metric == "satisfaction_score" else ".0f",
            cmap=cmap,
            vmin=vmin,
            vmax=vmax,
            ax=ax,
            cbar_kws={"label": self._get_metric_label(metric)},
            linewidths=0.5,
        )

        # Ïä§ÌÉÄÏùºÎßÅ
        ax.set_title(
            f"Signature √ó Emotion Matrix ({self._get_metric_label(metric)})",
            fontsize=16,
            fontweight="bold",
            pad=20,
        )
        ax.set_xlabel("Signatures", fontsize=12, fontweight="bold")
        ax.set_ylabel("Emotions", fontsize=12, fontweight="bold")

        # Ï∂ï Î†àÏù¥Î∏î ÌöåÏ†Ñ
        plt.xticks(rotation=45, ha="right")
        plt.yticks(rotation=0)

        # Î†àÏù¥ÏïÑÏõÉ Ï°∞Ï†ï
        plt.tight_layout()

        # Ï†ÄÏû•
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches="tight")
            print(f"üíæ ÌûàÌä∏Îßµ Ï†ÄÏû•: {save_path}")

        return fig

    def generate_completion_analysis(self, save_path: str = None) -> plt.Figure:
        """Îß§Ìä∏Î¶≠Ïä§ ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù Ï∞®Ìä∏"""
        print("üìà ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù Ï∞®Ìä∏ ÏÉùÏÑ±")

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))

        # 1. ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ ÏôÑÏÑ±ÎèÑ
        sig_completion = self._calculate_signature_completion()
        sig_completion.plot(kind="bar", ax=ax1, color="skyblue")
        ax1.set_title("SignatureÎ≥Ñ ÌÖúÌîåÎ¶ø ÏôÑÏÑ±ÎèÑ", fontweight="bold")
        ax1.set_ylabel("ÏôÑÏÑ±ÎèÑ (%)")
        ax1.tick_params(axis="x", rotation=45)

        # 2. Í∞êÏ†ïÎ≥Ñ Ïª§Î≤ÑÎ¶¨ÏßÄ
        emotion_coverage = self._calculate_emotion_coverage()
        emotion_coverage.plot(kind="bar", ax=ax2, color="lightcoral")
        ax2.set_title("EmotionÎ≥Ñ ÏãúÍ∑∏ÎãàÏ≤ò Ïª§Î≤ÑÎ¶¨ÏßÄ", fontweight="bold")
        ax2.set_ylabel("Ïª§Î≤Ñ ÏãúÍ∑∏ÎãàÏ≤ò Ïàò")
        ax2.tick_params(axis="x", rotation=45)

        # 3. ÏùëÎãµ Í∏∏Ïù¥ Î∂ÑÌè¨
        response_lengths = self._analyze_response_lengths()
        ax3.hist(response_lengths, bins=20, color="lightgreen", alpha=0.7)
        ax3.set_title("ÏùëÎãµ Í∏∏Ïù¥ Î∂ÑÌè¨", fontweight="bold")
        ax3.set_xlabel("ÏùëÎãµ Í∏∏Ïù¥ (Î¨∏Ïûê Ïàò)")
        ax3.set_ylabel("ÎπàÎèÑ")

        # 4. ÎßåÏ°±ÎèÑ Î∂ÑÌè¨ (ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í≤ΩÏö∞)
        if self.feedback_data:
            satisfaction_scores = [
                fb["satisfaction_score"]
                for fb in self.feedback_data
                if "satisfaction_score" in fb
            ]
            if satisfaction_scores:
                ax4.hist(satisfaction_scores, bins=10, color="gold", alpha=0.7)
                ax4.set_title("ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ Î∂ÑÌè¨", fontweight="bold")
                ax4.set_xlabel("ÎßåÏ°±ÎèÑ Ï†êÏàò")
                ax4.set_ylabel("ÎπàÎèÑ")
                ax4.axvline(
                    np.mean(satisfaction_scores),
                    color="red",
                    linestyle="--",
                    label=f"ÌèâÍ∑†: {np.mean(satisfaction_scores):.2f}",
                )
                ax4.legend()
            else:
                ax4.text(
                    0.5,
                    0.5,
                    "ÎßåÏ°±ÎèÑ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå",
                    ha="center",
                    va="center",
                    transform=ax4.transAxes,
                    fontsize=12,
                )
                ax4.set_title("ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ Î∂ÑÌè¨", fontweight="bold")
        else:
            ax4.text(
                0.5,
                0.5,
                "ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå",
                ha="center",
                va="center",
                transform=ax4.transAxes,
                fontsize=12,
            )
            ax4.set_title("ÏÇ¨Ïö©Ïûê ÎßåÏ°±ÎèÑ Î∂ÑÌè¨", fontweight="bold")

        plt.tight_layout()

        # Ï†ÄÏû•
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches="tight")
            print(f"üíæ ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù Ï∞®Ìä∏ Ï†ÄÏû•: {save_path}")

        return fig

    def generate_response_preview_table(self, max_chars: int = 50) -> pd.DataFrame:
        """ÏùëÎãµ ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖåÏù¥Î∏î ÏÉùÏÑ±"""
        print("üìã ÏùëÎãµ ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖåÏù¥Î∏î ÏÉùÏÑ±")

        preview_data = []

        for signature, sig_data in self.template_matrix.items():
            if isinstance(sig_data, dict):
                for emotion, emotion_data in sig_data.items():
                    if isinstance(emotion_data, dict) and "prompt" in emotion_data:
                        # ÏùëÎãµ ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú Î∞è Îã®Ï∂ï
                        response_text = emotion_data["prompt"]
                        if len(response_text) > max_chars:
                            response_text = response_text[:max_chars] + "..."

                        # ÎßåÏ°±ÎèÑ Ï†ïÎ≥¥ (ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ÏóêÏÑú)
                        satisfaction = self._get_satisfaction_for_combination(
                            signature, emotion
                        )

                        preview_data.append(
                            {
                                "Signature": signature,
                                "Emotion": emotion,
                                "Response_Preview": response_text,
                                "Style": emotion_data.get("style", "N/A"),
                                "Satisfaction": (
                                    f"{satisfaction:.1f}" if satisfaction else "N/A"
                                ),
                                "Has_Fallback": (
                                    "Yes" if "fallback" in emotion_data else "No"
                                ),
                            }
                        )

        df = pd.DataFrame(preview_data)
        print(f"üìä ÏÉùÏÑ±Îêú ÎØ∏Î¶¨Î≥¥Í∏∞: {len(df)}Í∞ú Ï°∞Ìï©")

        return df

    def identify_improvement_areas(self) -> Dict[str, Any]:
        """Í∞úÏÑ† ÌïÑÏöî ÏòÅÏó≠ ÏãùÎ≥Ñ"""
        print("üîç Í∞úÏÑ† ÌïÑÏöî ÏòÅÏó≠ Î∂ÑÏÑù")

        improvements = {
            "missing_combinations": [],
            "low_satisfaction_combinations": [],
            "short_responses": [],
            "missing_fallbacks": [],
            "underperforming_signatures": [],
            "underperforming_emotions": [],
        }

        # 1. ÎàÑÎùΩÎêú Ï°∞Ìï© ÏãùÎ≥Ñ
        all_signatures = list(self.template_matrix.keys())
        all_emotions = set()
        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                all_emotions.update(sig_data.keys())
        all_emotions = list(all_emotions)

        for signature in all_signatures:
            if isinstance(self.template_matrix[signature], dict):
                for emotion in all_emotions:
                    if emotion not in self.template_matrix[signature]:
                        improvements["missing_combinations"].append(
                            f"{signature} √ó {emotion}"
                        )

        # 2. ÎÇÆÏùÄ ÎßåÏ°±ÎèÑ Ï°∞Ìï©
        for signature, sig_data in self.template_matrix.items():
            if isinstance(sig_data, dict):
                for emotion in sig_data.keys():
                    satisfaction = self._get_satisfaction_for_combination(
                        signature, emotion
                    )
                    if satisfaction and satisfaction < 3.0:
                        improvements["low_satisfaction_combinations"].append(
                            f"{signature} √ó {emotion} (ÎßåÏ°±ÎèÑ: {satisfaction:.1f})"
                        )

        # 3. ÏßßÏùÄ ÏùëÎãµ ÏãùÎ≥Ñ
        for signature, sig_data in self.template_matrix.items():
            if isinstance(sig_data, dict):
                for emotion, emotion_data in sig_data.items():
                    if isinstance(emotion_data, dict) and "prompt" in emotion_data:
                        response_length = len(emotion_data["prompt"])
                        if response_length < 30:  # 30Ïûê ÎØ∏Îßå
                            improvements["short_responses"].append(
                                f"{signature} √ó {emotion} ({response_length}Ïûê)"
                            )

        # 4. Fallback ÎàÑÎùΩ ÏãùÎ≥Ñ
        for signature, sig_data in self.template_matrix.items():
            if isinstance(sig_data, dict):
                for emotion, emotion_data in sig_data.items():
                    if (
                        isinstance(emotion_data, dict)
                        and "fallback" not in emotion_data
                    ):
                        improvements["missing_fallbacks"].append(
                            f"{signature} √ó {emotion}"
                        )

        # 5. Ï†ÄÏÑ±Îä• ÏãúÍ∑∏ÎãàÏ≤ò/Í∞êÏ†ï
        if self.feedback_data:
            sig_performance = self._calculate_signature_performance()
            emotion_performance = self._calculate_emotion_performance()

            for sig, score in sig_performance.items():
                if score < 3.0:
                    improvements["underperforming_signatures"].append(
                        f"{sig} (ÌèâÍ∑†: {score:.1f})"
                    )

            for emotion, score in emotion_performance.items():
                if score < 3.0:
                    improvements["underperforming_emotions"].append(
                        f"{emotion} (ÌèâÍ∑†: {score:.1f})"
                    )

        print(f"üîç Í∞úÏÑ† ÏòÅÏó≠ ÏãùÎ≥Ñ ÏôÑÎ£å:")
        for category, items in improvements.items():
            if items:
                print(f"   {category}: {len(items)}Í∞ú")

        return improvements

    def generate_streamlit_dashboard(self):
        """Streamlit ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ±"""
        if not STREAMLIT_AVAILABLE:
            print("‚ùå StreamlitÏù¥ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïÑ ÎåÄÏãúÎ≥¥ÎìúÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
            return

        st.set_page_config(
            page_title="Echo Signature Response Matrix", page_icon="üé≠", layout="wide"
        )

        st.title("üé≠ Echo Signature Response Matrix Dashboard")
        st.markdown("Í∞êÏ†ï √ó ÏãúÍ∑∏ÎãàÏ≤ò ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§ ÏãúÍ∞ÅÌôî Î∞è Î∂ÑÏÑù")

        # ÏÇ¨Ïù¥ÎìúÎ∞î
        st.sidebar.header("üîß ÏãúÍ∞ÅÌôî ÏòµÏÖò")

        # Î©îÌä∏Î¶≠ ÏÑ†ÌÉù
        metric_options = {
            "response_count": "ÏùëÎãµ Ïàò",
            "satisfaction_score": "ÎßåÏ°±ÎèÑ Ï†êÏàò",
            "response_length": "ÏùëÎãµ Í∏∏Ïù¥",
        }
        selected_metric = st.sidebar.selectbox(
            "ÏãúÍ∞ÅÌôî Î©îÌä∏Î¶≠ ÏÑ†ÌÉù:",
            options=list(metric_options.keys()),
            format_func=lambda x: metric_options[x],
        )

        # Î©îÏù∏ ÎåÄÏãúÎ≥¥Îìú
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("Ï¥ù ÏãúÍ∑∏ÎãàÏ≤ò", self.matrix_analysis["signatures"])
        with col2:
            st.metric("Ï¥ù Í∞êÏ†ï", self.matrix_analysis["emotions"])
        with col3:
            st.metric("Ï¥ù Ï°∞Ìï©", self.matrix_analysis["total_combinations"])
        with col4:
            st.metric("ÏôÑÏÑ±ÎèÑ", f"{self.matrix_analysis['completion_rate']:.1%}")

        # ÌÉ≠ Íµ¨ÏÑ±
        tab1, tab2, tab3, tab4 = st.tabs(
            ["üìä Îß§Ìä∏Î¶≠Ïä§ ÌûàÌä∏Îßµ", "üìà ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù", "üìã ÏùëÎãµ ÎØ∏Î¶¨Î≥¥Í∏∞", "üîç Í∞úÏÑ† ÏòÅÏó≠"]
        )

        with tab1:
            st.subheader("üìä ÏãúÍ∑∏ÎãàÏ≤ò √ó Í∞êÏ†ï Îß§Ìä∏Î¶≠Ïä§")

            # ÌûàÌä∏Îßµ ÏÉùÏÑ± Î∞è ÌëúÏãú
            fig = self.generate_heatmap(metric=selected_metric)
            st.pyplot(fig)

            # Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î
            st.subheader("üìä Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞")
            matrix_data = self._create_matrix_data(selected_metric)
            st.dataframe(matrix_data.style.background_gradient(cmap="viridis"))

        with tab2:
            st.subheader("üìà Îß§Ìä∏Î¶≠Ïä§ ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù")

            # ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù Ï∞®Ìä∏
            fig = self.generate_completion_analysis()
            st.pyplot(fig)

            # ÏÉÅÏÑ∏ ÌÜµÍ≥Ñ
            col1, col2 = st.columns(2)

            with col1:
                st.subheader("ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ ÏôÑÏÑ±ÎèÑ")
                sig_completion = self._calculate_signature_completion()
                st.bar_chart(sig_completion)

            with col2:
                st.subheader("Í∞êÏ†ïÎ≥Ñ Ïª§Î≤ÑÎ¶¨ÏßÄ")
                emotion_coverage = self._calculate_emotion_coverage()
                st.bar_chart(emotion_coverage)

        with tab3:
            st.subheader("üìã ÏùëÎãµ ÎØ∏Î¶¨Î≥¥Í∏∞")

            # ÌïÑÌÑ∞ ÏòµÏÖò
            col1, col2 = st.columns(2)
            with col1:
                signature_filter = st.selectbox(
                    "ÏãúÍ∑∏ÎãàÏ≤ò ÌïÑÌÑ∞:",
                    options=["Ï†ÑÏ≤¥"] + list(self.template_matrix.keys()),
                )
            with col2:
                emotion_filter = st.selectbox(
                    "Í∞êÏ†ï ÌïÑÌÑ∞:",
                    options=["Ï†ÑÏ≤¥"]
                    + list(
                        set(
                            emotion
                            for sig_data in self.template_matrix.values()
                            if isinstance(sig_data, dict)
                            for emotion in sig_data.keys()
                        )
                    ),
                )

            # ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖåÏù¥Î∏î
            preview_df = self.generate_response_preview_table()

            # ÌïÑÌÑ∞ Ï†ÅÏö©
            if signature_filter != "Ï†ÑÏ≤¥":
                preview_df = preview_df[preview_df["Signature"] == signature_filter]
            if emotion_filter != "Ï†ÑÏ≤¥":
                preview_df = preview_df[preview_df["Emotion"] == emotion_filter]

            st.dataframe(preview_df, use_container_width=True)

        with tab4:
            st.subheader("üîç Í∞úÏÑ† ÌïÑÏöî ÏòÅÏó≠")

            improvements = self.identify_improvement_areas()

            for category, items in improvements.items():
                if items:
                    st.subheader(f"üìå {category.replace('_', ' ').title()}")
                    for item in items[:10]:  # ÏµúÎåÄ 10Í∞úÎßå ÌëúÏãú
                        st.write(f"‚Ä¢ {item}")
                    if len(items) > 10:
                        st.write(f"... Ïô∏ {len(items) - 10}Í∞ú Îçî")

        # Ìë∏ÌÑ∞
        st.markdown("---")
        st.markdown("üé≠ Echo Signature Response Matrix Dashboard v2.0")
        st.markdown(f"üìÖ ÏÉùÏÑ± ÏãúÍ∞Ñ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

    def _load_template_matrix(self) -> Dict[str, Any]:
        """ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§ Î°úÎî©"""
        try:
            template_path = self.data_dir / "signature_response_templates.yaml"
            if template_path.exists():
                with open(template_path, "r", encoding="utf-8") as f:
                    return yaml.safe_load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è ÌÖúÌîåÎ¶ø Îß§Ìä∏Î¶≠Ïä§ Î°úÎî© Ïã§Ìå®: {e}")

        return {}

    def _load_feedback_data(self) -> List[Dict[str, Any]]:
        """ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ Î°úÎî©"""
        feedback_data = []

        try:
            feedback_path = self.data_dir / "meta_logs" / "feedback_logs.jsonl"
            if feedback_path.exists():
                with open(feedback_path, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            feedback_data.append(json.loads(line))
        except Exception as e:
            print(f"‚ö†Ô∏è ÌîºÎìúÎ∞± Îç∞Ïù¥ÌÑ∞ Î°úÎî© Ïã§Ìå®: {e}")

        return feedback_data

    def _load_signature_profiles(self) -> Dict[str, Any]:
        """ÏãúÍ∑∏ÎãàÏ≤ò ÌîÑÎ°úÌïÑ Î°úÎî©"""
        return {
            "Selene": {"name": "Îã¨Îπõ Í∞ôÏùÄ ÏπòÏú†Ïûê", "color": "#87CEEB"},
            "Lune": {"name": "Ïã†ÎπÑÎ°úÏö¥ Îã¨Ïùò ÏàòÌò∏Ïûê", "color": "#B0C4DE"},
            "Aurora": {"name": "Ï∞ΩÏ°∞Ï†Å ÏòÅÍ∞êÏûê", "color": "#FFB6C1"},
            "Echo-Aurora": {"name": "Í≥µÍ∞êÏ†Å ÏñëÏú°Ïûê", "color": "#98FB98"},
            "Echo-Phoenix": {"name": "Î≥ÄÌôî Ï∂îÏßÑÏûê", "color": "#FFA500"},
            "Echo-Sage": {"name": "ÏßÄÌòúÎ°úÏö¥ Î∂ÑÏÑùÍ∞Ä", "color": "#DDA0DD"},
            "Echo-Companion": {"name": "Ïã†Î¢∞Ìï† Ïàò ÏûàÎäî ÎèôÎ∞òÏûê", "color": "#F0E68C"},
            "Grumbly": {"name": "ÍπåÏπ†Ìïú ÌòÑÏã§Ï£ºÏùòÏûê", "color": "#CD853F"},
        }

    def _analyze_matrix(self) -> Dict[str, Any]:
        """Îß§Ìä∏Î¶≠Ïä§ Î∂ÑÏÑù"""
        signatures = len(
            [k for k, v in self.template_matrix.items() if isinstance(v, dict)]
        )

        all_emotions = set()
        total_combinations = 0

        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                all_emotions.update(sig_data.keys())
                total_combinations += len(sig_data)

        emotions = len(all_emotions)
        max_possible_combinations = signatures * emotions
        completion_rate = (
            total_combinations / max_possible_combinations
            if max_possible_combinations > 0
            else 0
        )

        return {
            "signatures": signatures,
            "emotions": emotions,
            "total_combinations": total_combinations,
            "max_possible_combinations": max_possible_combinations,
            "completion_rate": completion_rate,
        }

    def _create_matrix_data(self, metric: str) -> pd.DataFrame:
        """Îß§Ìä∏Î¶≠Ïä§ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±"""
        # Î™®Îì† ÏãúÍ∑∏ÎãàÏ≤òÏôÄ Í∞êÏ†ï Ï∂îÏ∂ú
        signatures = [k for k, v in self.template_matrix.items() if isinstance(v, dict)]
        all_emotions = set()
        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                all_emotions.update(sig_data.keys())
        emotions = sorted(list(all_emotions))

        # Îß§Ìä∏Î¶≠Ïä§ Ï¥àÍ∏∞Ìôî
        matrix = np.zeros((len(emotions), len(signatures)))

        for i, emotion in enumerate(emotions):
            for j, signature in enumerate(signatures):
                if signature in self.template_matrix and isinstance(
                    self.template_matrix[signature], dict
                ):
                    if emotion in self.template_matrix[signature]:
                        if metric == "response_count":
                            matrix[i, j] = 1  # ÏùëÎãµÏù¥ ÏûàÏúºÎ©¥ 1
                        elif metric == "satisfaction_score":
                            satisfaction = self._get_satisfaction_for_combination(
                                signature, emotion
                            )
                            matrix[i, j] = satisfaction if satisfaction else 0
                        elif metric == "response_length":
                            emotion_data = self.template_matrix[signature][emotion]
                            if (
                                isinstance(emotion_data, dict)
                                and "prompt" in emotion_data
                            ):
                                matrix[i, j] = len(emotion_data["prompt"])

        return pd.DataFrame(matrix, index=emotions, columns=signatures)

    def _get_metric_label(self, metric: str) -> str:
        """Î©îÌä∏Î¶≠ ÎùºÎ≤® Î∞òÌôò"""
        labels = {
            "response_count": "ÏùëÎãµ Ïàò",
            "satisfaction_score": "ÎßåÏ°±ÎèÑ Ï†êÏàò",
            "response_length": "ÏùëÎãµ Í∏∏Ïù¥ (Î¨∏Ïûê)",
        }
        return labels.get(metric, metric)

    def _calculate_signature_completion(self) -> pd.Series:
        """ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ ÏôÑÏÑ±ÎèÑ Í≥ÑÏÇ∞"""
        all_emotions = set()
        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                all_emotions.update(sig_data.keys())
        total_emotions = len(all_emotions)

        completion_data = {}
        for signature, sig_data in self.template_matrix.items():
            if isinstance(sig_data, dict):
                completed_emotions = len(sig_data)
                completion_rate = (completed_emotions / total_emotions) * 100
                completion_data[signature] = completion_rate

        return pd.Series(completion_data)

    def _calculate_emotion_coverage(self) -> pd.Series:
        """Í∞êÏ†ïÎ≥Ñ Ïª§Î≤ÑÎ¶¨ÏßÄ Í≥ÑÏÇ∞"""
        coverage_data = {}

        # Î™®Îì† Í∞êÏ†ï Ï∂îÏ∂ú
        all_emotions = set()
        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                all_emotions.update(sig_data.keys())

        # Í∞Å Í∞êÏ†ïÎ≥ÑÎ°ú Ïª§Î≤ÑÌïòÎäî ÏãúÍ∑∏ÎãàÏ≤ò Ïàò Í≥ÑÏÇ∞
        for emotion in all_emotions:
            coverage_count = 0
            for signature, sig_data in self.template_matrix.items():
                if isinstance(sig_data, dict) and emotion in sig_data:
                    coverage_count += 1
            coverage_data[emotion] = coverage_count

        return pd.Series(coverage_data)

    def _analyze_response_lengths(self) -> List[int]:
        """ÏùëÎãµ Í∏∏Ïù¥ Î∂ÑÏÑù"""
        lengths = []

        for sig_data in self.template_matrix.values():
            if isinstance(sig_data, dict):
                for emotion_data in sig_data.values():
                    if isinstance(emotion_data, dict) and "prompt" in emotion_data:
                        lengths.append(len(emotion_data["prompt"]))

        return lengths

    def _get_satisfaction_for_combination(
        self, signature: str, emotion: str
    ) -> Optional[float]:
        """ÌäπÏ†ï Ï°∞Ìï©Ïùò ÎßåÏ°±ÎèÑ Ï°∞Ìöå"""
        if not self.feedback_data:
            return None

        relevant_feedback = [
            fb
            for fb in self.feedback_data
            if fb.get("signature") == signature and fb.get("emotion") == emotion
        ]

        if relevant_feedback:
            scores = [
                fb["satisfaction_score"]
                for fb in relevant_feedback
                if "satisfaction_score" in fb
            ]
            return np.mean(scores) if scores else None

        return None

    def _calculate_signature_performance(self) -> Dict[str, float]:
        """ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ ÏÑ±Îä• Í≥ÑÏÇ∞"""
        performance = {}

        for feedback in self.feedback_data:
            signature = feedback.get("signature")
            score = feedback.get("satisfaction_score")

            if signature and score:
                if signature not in performance:
                    performance[signature] = []
                performance[signature].append(score)

        # ÌèâÍ∑† Í≥ÑÏÇ∞
        for signature in performance:
            performance[signature] = np.mean(performance[signature])

        return performance

    def _calculate_emotion_performance(self) -> Dict[str, float]:
        """Í∞êÏ†ïÎ≥Ñ ÏÑ±Îä• Í≥ÑÏÇ∞"""
        performance = {}

        for feedback in self.feedback_data:
            emotion = feedback.get("emotion")
            score = feedback.get("satisfaction_score")

            if emotion and score:
                if emotion not in performance:
                    performance[emotion] = []
                performance[emotion].append(score)

        # ÌèâÍ∑† Í≥ÑÏÇ∞
        for emotion in performance:
            performance[emotion] = np.mean(performance[emotion])

        return performance


def main():
    """CLI Ïù∏ÌÑ∞ÌéòÏù¥Ïä§"""
    parser = argparse.ArgumentParser(description="Signature Response Matrix Visualizer")
    parser.add_argument(
        "--mode", choices=["static", "streamlit"], default="static", help="ÏãúÍ∞ÅÌôî Î™®Îìú"
    )
    parser.add_argument(
        "--metric",
        choices=["response_count", "satisfaction_score", "response_length"],
        default="response_count",
        help="ÏãúÍ∞ÅÌôî Î©îÌä∏Î¶≠",
    )
    parser.add_argument("--output", type=str, help="Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°ú")
    parser.add_argument("--analysis", action="store_true", help="Í∞úÏÑ† ÏòÅÏó≠ Î∂ÑÏÑù Ïã§Ìñâ")

    args = parser.parse_args()

    print("üìä Signature Response Visualizer")
    print("=" * 50)

    visualizer = SignatureResponseVisualizer()

    if args.mode == "streamlit":
        if STREAMLIT_AVAILABLE:
            print("üåê Streamlit ÎåÄÏãúÎ≥¥Îìú Ïã§Ìñâ Ï§ë...")
            visualizer.generate_streamlit_dashboard()
        else:
            print("‚ùå StreamlitÏù¥ ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå")
    else:
        print(f"üé® Ï†ïÏ†Å ÏãúÍ∞ÅÌôî ÏÉùÏÑ±: {args.metric}")

        # ÌûàÌä∏Îßµ ÏÉùÏÑ±
        output_path = args.output or f"signature_matrix_{args.metric}.png"
        fig = visualizer.generate_heatmap(metric=args.metric, save_path=output_path)

        # ÏôÑÏÑ±ÎèÑ Î∂ÑÏÑù
        completion_path = output_path.replace(".png", "_completion.png")
        completion_fig = visualizer.generate_completion_analysis(
            save_path=completion_path
        )

        # ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖåÏù¥Î∏î
        preview_df = visualizer.generate_response_preview_table()
        csv_path = output_path.replace(".png", "_preview.csv")
        preview_df.to_csv(csv_path, index=False, encoding="utf-8-sig")
        print(f"üìã ÎØ∏Î¶¨Î≥¥Í∏∞ ÌÖåÏù¥Î∏î Ï†ÄÏû•: {csv_path}")

        # Í∞úÏÑ† ÏòÅÏó≠ Î∂ÑÏÑù
        if args.analysis:
            improvements = visualizer.identify_improvement_areas()
            analysis_path = output_path.replace(".png", "_analysis.json")
            with open(analysis_path, "w", encoding="utf-8") as f:
                json.dump(improvements, f, ensure_ascii=False, indent=2)
            print(f"üîç Í∞úÏÑ† ÏòÅÏó≠ Î∂ÑÏÑù Ï†ÄÏû•: {analysis_path}")

        print("‚úÖ ÏãúÍ∞ÅÌôî ÏôÑÎ£å!")


if __name__ == "__main__":
    main()
