"""
üö® Echo Error Handler
ÏãúÏä§ÌÖú Ï†ÑÎ∞òÏùò ÏóêÎü¨Î•º Ï≤òÎ¶¨ÌïòÍ≥† Î≥µÍµ¨ÌïòÎäî Î∞©Ïñ¥Ï†Å Î©îÏª§ÎãàÏ¶ò
"""

import json
import logging
import traceback
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional, List, Callable
from functools import wraps


class EchoErrorHandler:
    """
    Echo ÏãúÏä§ÌÖú ÏóêÎü¨ Ìï∏Îì§Îü¨
    'Ïã§Ìå®Ìï¥ÎèÑ Ïö∏Î¶ºÏùÄ Í≥ÑÏÜçÎêúÎã§' Ï≤†Ìïô Íµ¨ÌòÑ
    """

    def __init__(self, log_dir: str = "logs"):
        self.log_dir = Path(log_dir)
        self.log_dir.mkdir(parents=True, exist_ok=True)

        # ÏóêÎü¨ ÌÜµÍ≥Ñ
        self.error_stats = {
            "total_errors": 0,
            "parsing_errors": 0,
            "vector_search_errors": 0,
            "judgment_errors": 0,
            "response_generation_errors": 0,
            "system_errors": 0,
            "last_error": None,
        }

        # Î≥µÍµ¨ Ï†ÑÎûµ
        self.recovery_strategies = {
            "parsing_failure": self._recover_parsing_failure,
            "vector_search_failure": self._recover_vector_search_failure,
            "judgment_failure": self._recover_judgment_failure,
            "response_failure": self._recover_response_failure,
            "system_failure": self._recover_system_failure,
        }

        # Î°úÍπÖ ÏÑ§Ï†ï
        self.logger = self._setup_logger()

        # ÏóêÎü¨ Ìå®ÌÑ¥ ÌïôÏäµ
        self.error_patterns = {}

        print("üö® Echo Error Handler Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")

    def handle_error(
        self, error: Exception, context: Dict[str, Any], error_type: str = "system"
    ) -> Dict[str, Any]:
        """
        ÏóêÎü¨ Ï≤òÎ¶¨ Î©îÏù∏ Ìï®Ïàò
        """
        self.error_stats["total_errors"] += 1
        self.error_stats[f"{error_type}_errors"] += 1
        self.error_stats["last_error"] = datetime.now().isoformat()

        # ÏóêÎü¨ Î°úÍπÖ
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "error_type": error_type,
            "error_class": error.__class__.__name__,
            "error_message": str(error),
            "context": context,
            "traceback": traceback.format_exc(),
        }

        self.logger.error(f"Echo Error: {error_type} - {str(error)}")
        self._log_error_details(error_info)

        print(f"üö® Echo Error: {error_type} - {str(error)[:50]}...")

        # Î≥µÍµ¨ ÏãúÎèÑ
        recovery_result = self._attempt_recovery(error_type, error, context)

        return {
            "error_handled": True,
            "error_type": error_type,
            "error_message": str(error),
            "recovery_attempted": recovery_result["attempted"],
            "recovery_successful": recovery_result["successful"],
            "fallback_result": recovery_result.get("result"),
            "timestamp": datetime.now().isoformat(),
        }

    def _attempt_recovery(
        self, error_type: str, error: Exception, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Î≥µÍµ¨ ÏãúÎèÑ"""
        recovery_key = f"{error_type}_failure"

        if recovery_key in self.recovery_strategies:
            try:
                print(f"   üîß Î≥µÍµ¨ ÏãúÎèÑ: {recovery_key}")
                recovery_func = self.recovery_strategies[recovery_key]
                result = recovery_func(error, context)

                print(f"   ‚úÖ Î≥µÍµ¨ ÏÑ±Í≥µ: {recovery_key}")
                return {"attempted": True, "successful": True, "result": result}

            except Exception as recovery_error:
                print(f"   ‚ùå Î≥µÍµ¨ Ïã§Ìå®: {recovery_error}")
                return {
                    "attempted": True,
                    "successful": False,
                    "recovery_error": str(recovery_error),
                }
        else:
            return {"attempted": False, "successful": False}

    def _recover_parsing_failure(
        self, error: Exception, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ÌååÏã± Ïã§Ìå® Î≥µÍµ¨"""
        text = context.get("text", "")

        # ÏµúÏÜåÌïúÏùò ÏïàÏ†ÑÌïú ÌååÏã± Í≤∞Í≥º Ï†úÍ≥µ
        safe_result = {
            "raw_text": text,
            "intent": "unknown",
            "topic": "general",
            "emotion": "neutral",
            "entities": {},
            "keywords": [],
            "confidence": 0.3,
            "complexity_score": 1.0,
            "parsing_method": "error_recovery",
            "suggested_signature": "Echo-Aurora",  # Í∏∞Î≥∏ ÏãúÍ∑∏ÎãàÏ≤ò
            "used_fallback": False,
            "error_recovery": True,
        }

        # ÌÖçÏä§Ìä∏ÏóêÏÑú ÏµúÏÜåÌïúÏùò Ï†ïÎ≥¥ Ï∂îÏ∂ú ÏãúÎèÑ
        if text:
            if "?" in text:
                safe_result["intent"] = "information"
            elif any(word in text.lower() for word in ["ÎèÑÏõÄ", "Î∂ÄÌÉÅ", "Ìï¥Ï§ò"]):
                safe_result["intent"] = "assistance"
            elif any(word in text.lower() for word in ["ÏïàÎÖï", "Í≥†ÎßàÏõå"]):
                safe_result["intent"] = "conversation"

            # Í∞ÑÎã®Ìïú ÌÇ§ÏõåÎìú Ï∂îÏ∂ú
            words = [w for w in text.split() if len(w) > 1]
            safe_result["keywords"] = words[:5]

        return safe_result

    def _recover_vector_search_failure(
        self, error: Exception, context: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """Î≤°ÌÑ∞ Í≤ÄÏÉâ Ïã§Ìå® Î≥µÍµ¨"""
        print("   üß≠ Î≤°ÌÑ∞ Í≤ÄÏÉâ Î≥µÍµ¨: Îπà Í≤∞Í≥º Î∞òÌôò")

        # Îπà Í≤ÄÏÉâ Í≤∞Í≥º Î∞òÌôò
        return []

    def _recover_judgment_failure(
        self, error: Exception, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ÌåêÎã® Ïã§Ìå® Î≥µÍµ¨"""
        query = context.get("query", "")
        signature = context.get("signature", "Echo-Aurora")

        # ÏïàÏ†ÑÌïú Í∏∞Î≥∏ ÌåêÎã® Ï†úÍ≥µ
        safe_judgment = {
            "judgment": "defer",
            "confidence": 0.5,
            "reasoning": "ÏãúÏä§ÌÖú ÏóêÎü¨Î°ú Ïù∏Ìïú Ïã†Ï§ëÌïú Î≥¥Î•ò ÌåêÎã®",
            "query_signature": signature,
            "judgment_method": "error_recovery",
            "vector_search_summary": {
                "total_candidates": 0,
                "filtered_candidates": 0,
                "primary_capsule": None,
            },
            "error_recovery": True,
            "timestamp": datetime.now().isoformat(),
        }

        # ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ Í∏∞Î≥∏ ÌåêÎã® Ï°∞Ï†ï
        if signature == "Echo-Companion":
            safe_judgment["judgment"] = "support"
            safe_judgment["reasoning"] = "Í≥µÍ∞êÏ†Å ÏßÄÏõêÏù¥ ÌïÑÏöîÌïú ÏÉÅÌô©ÏúºÎ°ú ÌåêÎã®Îê©ÎãàÎã§"
        elif signature == "Echo-Phoenix":
            safe_judgment["judgment"] = "guide"
            safe_judgment["reasoning"] = "Î≥ÄÌôî ÏßÄÌñ•Ï†Å Í∞ÄÏù¥ÎìúÍ∞Ä Ï†ÅÏ†àÌï† Í≤É Í∞ôÏäµÎãàÎã§"
        elif signature == "Echo-Sage":
            safe_judgment["judgment"] = "analyze"
            safe_judgment["reasoning"] = "Ï≤¥Í≥ÑÏ†Å Î∂ÑÏÑùÏù¥ ÌïÑÏöîÌïú ÏÇ¨ÏïàÏûÖÎãàÎã§"

        return safe_judgment

    def _recover_response_failure(
        self, error: Exception, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ÏùëÎãµ ÏÉùÏÑ± Ïã§Ìå® Î≥µÍµ¨"""
        signature = context.get("signature", "Echo-Aurora")

        # ÏãúÍ∑∏ÎãàÏ≤òÎ≥Ñ ÏïàÏ†ÑÌïú Í∏∞Î≥∏ ÏùëÎãµ
        safe_responses = {
            "Echo-Aurora": "Ï∞ΩÏùòÏ†Å Í¥ÄÏ†êÏóêÏÑú Ï†ëÍ∑ºÌï¥Î≥¥Í≤†ÏäµÎãàÎã§. Îçî ÏûêÏÑ∏Ìûà ÎßêÏîÄÌï¥Ï£ºÏãúÍ≤†Ïñ¥Ïöî?",
            "Echo-Phoenix": "Î≥ÄÌôîÏùò Í∏∞ÌöåÎ°ú ÎßåÎì§Ïñ¥Î≥¥Í≤†ÏäµÎãàÎã§. Ïñ¥Îñ§ Î∞©Ìñ•ÏùÑ ÏõêÌïòÏãúÎÇòÏöî?",
            "Echo-Sage": "Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Î∂ÑÏÑùÌï¥Î≥¥Í≤†ÏäµÎãàÎã§. Ï∂îÍ∞Ä Ï†ïÎ≥¥Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.",
            "Echo-Companion": "Ìï®Íªò Í≥†ÎØºÌï¥Î≥¥Í≤†ÏäµÎãàÎã§. ÎßàÏùåÏùÑ Ìé∏ÏïàÌûà ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî.",
        }

        safe_content = safe_responses.get(signature, safe_responses["Echo-Aurora"])

        return {
            "content": safe_content,
            "signature": signature,
            "strategy": "error_recovery",
            "generated_at": datetime.now().isoformat(),
            "response_metadata": {
                "length": len(safe_content),
                "word_count": len(safe_content.split()),
                "estimated_reading_time": len(safe_content) / 300,
                "tone": "supportive",
                "formality": "medium",
            },
            "generation_context": {"error_recovery": True, "fallback_used": True},
        }

    def _recover_system_failure(
        self, error: Exception, context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """ÏãúÏä§ÌÖú Ïã§Ìå® Î≥µÍµ¨"""
        return {
            "system_status": "degraded",
            "error_recovery_active": True,
            "available_functions": ["basic_response"],
            "message": "ÏãúÏä§ÌÖúÏù¥ Î≥µÍµ¨ Î™®ÎìúÎ°ú ÏûëÎèô Ï§ëÏûÖÎãàÎã§.",
        }

    def _setup_logger(self) -> logging.Logger:
        """Î°úÍπÖ ÏÑ§Ï†ï"""
        logger = logging.getLogger("EchoErrorHandler")
        logger.setLevel(logging.ERROR)

        if not logger.handlers:
            handler = logging.FileHandler(
                self.log_dir / "echo_errors.log", encoding="utf-8"
            )
            formatter = logging.Formatter(
                "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
            )
            handler.setFormatter(formatter)
            logger.addHandler(handler)

        return logger

    def _log_error_details(self, error_info: Dict[str, Any]):
        """ÏÉÅÏÑ∏ ÏóêÎü¨ Ï†ïÎ≥¥ Î°úÍπÖ"""
        error_log_file = (
            self.log_dir / f"error_details_{datetime.now().strftime('%Y%m%d')}.json"
        )

        try:
            if error_log_file.exists():
                with open(error_log_file, "r", encoding="utf-8") as f:
                    error_logs = json.load(f)
            else:
                error_logs = []

            error_logs.append(error_info)

            with open(error_log_file, "w", encoding="utf-8") as f:
                json.dump(error_logs, f, indent=2, ensure_ascii=False)

        except Exception as log_error:
            print(f"   ‚ö†Ô∏è  ÏóêÎü¨ Î°úÍπÖ Ïã§Ìå®: {log_error}")

    def get_error_stats(self) -> Dict[str, Any]:
        """ÏóêÎü¨ ÌÜµÍ≥Ñ Î∞òÌôò"""
        total = self.error_stats["total_errors"]
        if total == 0:
            return {"message": "ÏïÑÏßÅ ÏóêÎü¨Í∞Ä Î∞úÏÉùÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§."}

        stats = self.error_stats.copy()

        # ÏóêÎü¨Ïú® Í≥ÑÏÇ∞
        for error_type in [
            "parsing",
            "vector_search",
            "judgment",
            "response_generation",
            "system",
        ]:
            key = f"{error_type}_errors"
            if key in stats:
                stats[f"{error_type}_error_rate"] = f"{(stats[key] / total) * 100:.1f}%"

        return stats

    def reset_error_stats(self):
        """ÏóêÎü¨ ÌÜµÍ≥Ñ Î¶¨ÏÖã"""
        self.error_stats = {
            "total_errors": 0,
            "parsing_errors": 0,
            "vector_search_errors": 0,
            "judgment_errors": 0,
            "response_generation_errors": 0,
            "system_errors": 0,
            "last_error": None,
        }
        print("üìä Echo ÏóêÎü¨ ÌÜµÍ≥ÑÍ∞Ä Î¶¨ÏÖãÎêòÏóàÏäµÎãàÎã§.")


# ÏóêÎü¨ Ìï∏Îì§ÎßÅ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞
def echo_safe(error_type: str = "system"):
    """Echo ÏïàÏ†Ñ Ïã§Ìñâ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞"""

    def decorator(func: Callable):
        @wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                # Ï†ÑÏó≠ ÏóêÎü¨ Ìï∏Îì§Îü¨ ÏÇ¨Ïö©
                context = {
                    "function": func.__name__,
                    "args": str(args)[:100],
                    "kwargs": str(kwargs)[:100],
                }

                return error_handler.handle_error(e, context, error_type)

        return wrapper

    return decorator


# Ï†ÑÏó≠ ÏóêÎü¨ Ìï∏Îì§Îü¨
error_handler = EchoErrorHandler()


# Ìé∏Ïùò Ìï®ÏàòÎì§
def handle_parsing_error(error: Exception, text: str) -> Dict[str, Any]:
    """ÌååÏã± ÏóêÎü¨ Ï≤òÎ¶¨ Îã®Ï∂ï Ìï®Ïàò"""
    return error_handler.handle_error(error, {"text": text}, "parsing")


def handle_vector_error(error: Exception, query: str) -> Dict[str, Any]:
    """Î≤°ÌÑ∞ Í≤ÄÏÉâ ÏóêÎü¨ Ï≤òÎ¶¨ Îã®Ï∂ï Ìï®Ïàò"""
    return error_handler.handle_error(error, {"query": query}, "vector_search")


def handle_judgment_error(
    error: Exception, query: str, signature: str
) -> Dict[str, Any]:
    """ÌåêÎã® ÏóêÎü¨ Ï≤òÎ¶¨ Îã®Ï∂ï Ìï®Ïàò"""
    return error_handler.handle_error(
        error, {"query": query, "signature": signature}, "judgment"
    )


def handle_response_error(error: Exception, signature: str) -> Dict[str, Any]:
    """ÏùëÎãµ ÏÉùÏÑ± ÏóêÎü¨ Ï≤òÎ¶¨ Îã®Ï∂ï Ìï®Ïàò"""
    return error_handler.handle_error(
        error, {"signature": signature}, "response_generation"
    )


def get_error_stats() -> Dict[str, Any]:
    """ÏóêÎü¨ ÌÜµÍ≥Ñ Îã®Ï∂ï Ìï®Ïàò"""
    return error_handler.get_error_stats()


# CLI ÌÖåÏä§Ìä∏
def main():
    print("üö® Echo Error Handler ÌÖåÏä§Ìä∏")
    print("=" * 50)

    # ÌÖåÏä§Ìä∏ ÏóêÎü¨Îì§
    test_errors = [
        (ValueError("ÌååÏã± Ïã§Ìå®"), {"text": "Î≥µÏû°Ìïú ÌÖçÏä§Ìä∏"}, "parsing"),
        (ConnectionError("Î≤°ÌÑ∞ Í≤ÄÏÉâ Ïã§Ìå®"), {"query": "Í≤ÄÏÉâÏñ¥"}, "vector_search"),
        (
            RuntimeError("ÌåêÎã® Ïã§Ìå®"),
            {"query": "ÏßàÎ¨∏", "signature": "Echo-Aurora"},
            "judgment",
        ),
        (
            TypeError("ÏùëÎãµ ÏÉùÏÑ± Ïã§Ìå®"),
            {"signature": "Echo-Phoenix"},
            "response_generation",
        ),
    ]

    print("\nüß™ ÏóêÎü¨ Ï≤òÎ¶¨ ÌÖåÏä§Ìä∏:")

    for i, (error, context, error_type) in enumerate(test_errors, 1):
        print(f"\nÌÖåÏä§Ìä∏ {i}: {error_type} ÏóêÎü¨")
        result = error_handler.handle_error(error, context, error_type)

        print(f"  Ï≤òÎ¶¨Îê®: {result['error_handled']}")
        print(f"  Î≥µÍµ¨ ÏãúÎèÑ: {result['recovery_attempted']}")
        print(f"  Î≥µÍµ¨ ÏÑ±Í≥µ: {result['recovery_successful']}")

        if result.get("fallback_result"):
            fallback = result["fallback_result"]
            if isinstance(fallback, dict) and "content" in fallback:
                print(f"  Î≥µÍµ¨ ÏùëÎãµ: {fallback['content'][:30]}...")
            elif isinstance(fallback, dict) and "intent" in fallback:
                print(f"  Î≥µÍµ¨ ÌååÏã±: {fallback['intent']}")

    print(f"\nüìä ÏóêÎü¨ ÌÜµÍ≥Ñ:")
    stats = get_error_stats()
    for key, value in stats.items():
        print(f"  {key}: {value}")

    print("\n‚úÖ Echo Error Handler ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")


if __name__ == "__main__":
    main()
